문제 설명

약수의 개수가 세 개 이상인 수를 합성수라고 합니다. 자연수 n이 매개변수로 주어질 때 n이하의 합성수의 개수를 return하도록 solution 함수를 완성해주세요.

---

제한사항

-   1 ≤ n ≤ 100

---

입출력 예

n     result

| 10 | 5 |
| --- | --- |
| 15 | 8 |

---

입출력 예 설명

입출력 예 #1

-   10 이하 합성수는 4, 6, 8, 9, 10 로 5개입니다. 따라서 5를 return합니다.

입출력 예 #1

-   15 이하 합성수는 4, 6, 8, 9, 10, 12, 14, 15 로 8개입니다. 따라서 8을 return합니다.

풀이)

```
function solution(n) {
  let result = 0;
  for (let i = 4; i <= n; i++) {
    let divisor = [];
    //합성수는 4부터 시작하기때문에 4부터 체크
    for (let j = 1; j <= i; j++) {
      if (i % j === 0) {
        divisor.push(j);
      }
    }
    if (divisor.length >= 3) {
      result++;
    }
  }
  return result;
}
```

첫번째 for문은 n이하의 수가 합성수인지 아닌지를 체크하는거고 

1,2,3은 합성수가 될 가능성이 없기때문에 4부터 시작했다. 

두번째 for문은 i의 약수를 구하기 위해 돌렸고 약수들을 모아서 배열로 만들었다.

그래서 그 배열의 길이가 3이상이면 합성수이기때문에 그 배열을  count한것을 리턴했다.

중간에 로직은 그대로인데 답이 제대로 안나오길래 확인했더니 

 divisor 배열이 제대로 초기화가 안돼서 일어나는 문제여서  divisor을 for문 안쪽으로 옮겼더니 잘 실행이 되었다.

```
function solution(n) {
    var answer = 0;
    for(let i = 4; i <= n; i++){
        for(let j = 2; j < i; j++){
            if(i % j === 0){
                answer += 1;
                break;
            }
        }
    }

    return answer;
}
```

더 줄여보면 합성수는 1과 자기자신 빼고는 그 이외에 약수가 하나라도 더있다면 합성수가 되기 때문에

j를 2부터 검사하면 1과 자기 자신 이외에 하나가 더있으니까 무조건 답이 돼서 배열에 추가하는 과정을 생략해도 된다

또사실은 j < i까지 검사할 필요없이 j <= Math.sqrt(i) 까지만 검사해도 된다.

예를들어 16이면

1, 2, 4, 8, 16이 약수인 합성수인데

1과 16이 매칭

2와 8이 매칭

4,4가 매칭이 된다,

제곱근인 4까지만 검사를 해도 1과 자기자신을 제외한 2부터 매칭이 되는 것이 있다면 합성수이기때문에

제곱근까지만 검사해도 합성수인지 판별할수 있게된다.
